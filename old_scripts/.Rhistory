sapply(mod_ids, function(mid) {
msize <- as.integer(modtb[mid])
if (msize < 2) return(NA_real_)
idx <- sample(all_genes, msize, replace = FALSE)
compute_MDC(expr_young, expr_old, idx, power = corrlpower)
})
})
colnames(GlobalyRandomMDC) <- sprintf("MDC_random_genes_%02d", seq_len(no.perms))
p_samp <- mapply(function(obs, i) empirical_p(obs, meanFoldChange[i, ]), obs = yfold, i = seq_along(yfold))
p_gene <- mapply(function(obs, i) empirical_p(obs, GlobalyRandomMDC[i, ]), obs = yfold, i = seq_along(yfold))
q_samp <- p.adjust(p_samp, method = "BH")
q_gene <- p.adjust(p_gene, method = "BH")
q_max  <- pmax(q_samp, q_gene)   # conservative combination (like taking max of two FDRs)
final <- data.frame(
module = mod_ids,
size   = as.integer(modtb[mid]),
MDC    = round(yfold, 4),
p_random_samples = signif(p_samp, 4),
q_random_samples = signif(q_samp, 4),
p_random_genes   = signif(p_gene, 4),
q_random_genes   = signif(q_gene, 4),
q_combined_max   = signif(q_max, 4),
check.names = FALSE
)
message(sprintf("Gene permutations × %d ...", no.perms))
all_genes <- seq_len(ncol(expr_young))
GlobalyRandomMDC <- replicate(no.perms, {
sapply(mod_ids, function(mid) {
msize <- as.integer(modtb[as.character(mid)])
if (is.na(msize) || msize < 2) return(NA_real_)
idx <- sample(all_genes, msize, replace = FALSE)
compute_MDC(expr_young, expr_old, idx, power = corrlpower)
})
})
rownames(GlobalyRandomMDC) <- as.character(mod_ids)
colnames(GlobalyRandomMDC) <- sprintf("MDC_random_genes_%02d", seq_len(no.perms))
p_samp <- vapply(seq_along(yfold), function(i) {
empirical_p(yfold[i], meanFoldChange[ names(yfold)[i], ])
}, numeric(1))
names(p_samp) <- names(yfold)
p_gene <- vapply(seq_along(yfold), function(i) {
empirical_p(yfold[i], GlobalyRandomMDC[ names(yfold)[i], ])
}, numeric(1))
names(p_gene) <- names(yfold)
q_samp <- p.adjust(p_samp, method = "BH")
q_gene <- p.adjust(p_gene, method = "BH")
q_max  <- pmax(q_samp, q_gene)
mod_ids_char <- names(yfold)
final <- data.frame(
module = as.integer(mod_ids_char),
size   = as.integer(modtb[mod_ids_char]),
MDC    = round(unname(yfold), 4),
p_random_samples = signif(unname(p_samp), 4),
q_random_samples = signif(unname(q_samp), 4),
p_random_genes   = signif(unname(p_gene), 4),
q_random_genes   = signif(unname(q_gene), 4),
q_combined_max   = signif(unname(q_max), 4),
check.names = FALSE
)
final <- final[order(-final$MDC), ]
stopifnot(all(rownames(meanFoldChange)   %in% mod_ids_char))
stopifnot(all(rownames(GlobalyRandomMDC) %in% mod_ids_char))
randoms <- cbind(
module = as.integer(mod_ids_char),
setNames(as.data.frame(t(meanFoldChange[mod_ids_char, , drop=FALSE]), check.names = FALSE),
paste0("tmp_remove_me")), # placeholder to transpose back after cbind
stringsAsFactors = FALSE
)
randoms <- data.frame(
module = as.integer(mod_ids_char),
as.data.frame(meanFoldChange[mod_ids_char, , drop=FALSE], check.names = FALSE),
as.data.frame(GlobalyRandomMDC[mod_ids_char, , drop=FALSE], check.names = FALSE),
check.names = FALSE
)
colnames(randoms) <- c(
"module",
sprintf("MDC_random_samples_%02d", seq_len(ncol(meanFoldChange))),
sprintf("MDC_random_genes_%02d",  seq_len(ncol(GlobalyRandomMDC)))
)
write.table(final,
file = file.path(out_dir, paste0(run_name, "_MDC_wFDR.tsv")),
sep = "\t", quote = FALSE, row.names = FALSE)
write.table(randoms,
file = file.path(out_dir, paste0(run_name, "_MDC_randoms.tsv")),
sep = "\t", quote = FALSE, row.names = FALSE)
message("Saved: ", file.path(out_dir, paste0(run_name, "_MDC_wFDR.tsv")))
message("Saved: ", file.path(out_dir, paste0(run_name, "_MDC_randoms.tsv")))
png(file.path(out_dir, "plots", paste0(run_name, "_MDC_barplot.png")),
width = 2000, height = 900, res = 180)
op <- par(mar = c(9, 5, 3, 1))
lab <- final$module
cols <- rep_len(setdiff(colors(), c("white","grey","gray","lightgray")), length(lab))
stars <- ifelse(final$q_combined_max <= alpha, "*", "")
bp <- barplot(final$MDC, names.arg = lab, las = 2,
ylab = sprintf("MDC (k_%s / k_%s)", "young", "old"),
col = cols[seq_along(lab)], border = NA)
text(bp, final$MDC, labels = stars, pos = 3, cex = 1.1)
abline(h = 1, lty = 2)
par(op)
dev.off()
message("Saved: ", file.path(out_dir, "plots", paste0(run_name, "_MDC_barplot.png")))
topK <- min(12L, nrow(final))
dir.create(file.path(out_dir, "plots", "heatmaps"), showWarnings = FALSE)
# Order modules by MDC already in 'final'
for (z in seq_len(topK)) {
mid <- final$module[z]
idx <- genes_idx_of_module(mid)
if (length(idx) < 2) next
corB <- abs(cor(expr_young[, idx, drop=FALSE], use="pairwise.complete.obs"))^corrlpower
corA <- abs(cor(expr_old  [, idx, drop=FALSE], use="pairwise.complete.obs"))^corrlpower
diag(corB) <- 0; diag(corA) <- 0
ord <- order(rowSums(corB, na.rm=TRUE), decreasing = TRUE)
CB <- corB[ord, ord]; CA <- corA[ord, ord]
U  <- CB; L <- CA
U[lower.tri(U, diag=TRUE)] <- NA
L[upper.tri(L, diag=TRUE)] <- NA
M <- U; M[is.na(M)] <- L[is.na(M)]
png(file.path(out_dir, "plots", "heatmaps",
sprintf("%s_heatmap_module%d.png", run_name, mid)),
width = 800, height = 800, res = 140)
par(mar=c(2,2,2,2))
image(t(apply(M, 2, rev)), axes=FALSE, col = heat.colors(64),
main = sprintf("Module %d (top %d/%d genes)", mid, length(idx), as.integer(modtb[as.character(mid)])))
box()
dev.off()
}
message("Done numeric module MDC pipeline.")
source("~/CoExpression_ReProduction/old_scripts/CrossTissueClusteringMethods.R")
res <- XWGCNA_Clusters_autoBeta(
tissue_names = c("Adipose","Muscle","Brain"),
tissue_expr_file_names = c(
"/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Adipose - Subcutaneous/old_matrix.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Muscle - Skeletal/old_matrix.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Brain - Cortex/old_matrix.csv"
),
sd_quantile = 0.50,
max_genes_per_tissue = 5000,     # if RAM is tight try 2000–3000
min_expr = 0,
min_prop = 0.10,
auto_beta = TRUE,
targetR2 = 0.80,
beta_grid = 1:20,
minClusterSize = 30,
cluster_type_thr = 0.95,
out_prefix = "xwgcna_old_auto_run1",
save_intermediates = TRUE,
plot_heatmap = TRUE
)
source("~/CoExpression_ReProduction/old_scripts/CrossTissueClusteringMethods.R")
res <- XWGCNA_Clusters_autoBeta(
tissue_names = c("Adipose","Muscle","Brain"),
tissue_expr_file_names = c(
"/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Adipose - Subcutaneous/young_matrix.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Muscle - Skeletal/young_matrix.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Brain - Cortex/young_matrix.csv"
),
sd_quantile = 0.50,
max_genes_per_tissue = 5000,
min_expr = 0,
min_prop = 0.10,
auto_beta = TRUE,
targetR2 = 0.80,
beta_grid = 1:20,
minClusterSize = 30,
cluster_type_thr = 0.95,
out_prefix = "xwgcna_young_auto_run2",
save_intermediates = TRUE,
plot_heatmap = TRUE
)
files_old <- c(
Adipose="/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Adipose - Subcutaneous/old_matrix.csv",
Muscle ="/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Muscle - Skeletal/old_matrix.csv",
Brain  ="/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Brain - Cortex/old_matrix.csv"
)
files_young <- c(
Adipose="/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Adipose - Subcutaneous/young_matrix.csv",
Muscle ="/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Muscle - Skeletal/young_matrix.csv",
Brain  ="/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Brain - Cortex/young_matrix.csv"
)
clusters_table_path <- "/Users/edeneldar/CoExpression_ReProduction/old_scripts/interTissueClusteringAutoBeta/xwgcna_young_auto_run2_Clusters_table.txt"  # columns: Cluster ID,Tissue,Gene Symbol
# clu <- read.delim("xwgcna_young_auto_run1_Clusters_table.txt", check.names = FALSE)
out_dir     <- "MDC_out_run2"
run_name    <- "young_vs_old"
set.seed(42)
# Analysis knobs
corrlpower  <- 6          # like WGCNA soft-threshold (β) used for within-cohort correlation
no.perms    <- 100         # increase to 100/200 for stronger nulls
alpha       <- 0.10       # significance threshold for bars
# ---------- Packages ----------
suppressPackageStartupMessages({
library(WGCNA)   # for labels2colors
})
# ---------- Helpers ----------
.extract_donor <- function(x) sub("^([^-]+-[^-]+).*", "\\1", x)
read_tissue_expr <- function(path, tissue, check.names=FALSE) {
X <- read.csv(path, check.names = check.names)
if (ncol(X) < 2) stop("Bad CSV: expect first column=sample IDs, others=genes")
rownames(X) <- X[,1]
X <- as.matrix(X[,-1, drop=FALSE])
colnames(X) <- paste0(tissue, "_", colnames(X))  # Tissue_Gene
storage.mode(X) <- "double"
X
}
aggregate_by_donor <- function(M) {
d <- .extract_donor(rownames(M))
idx <- split(seq_len(nrow(M)), d)
A <- do.call(rbind, lapply(idx, function(ix) colMeans(M[ix, , drop=FALSE], na.rm=TRUE)))
rownames(A) <- names(idx)
A
}
assemble_cohort_matrix <- function(files_by_tissue) {
mats <- lapply(names(files_by_tissue), function(t) {
M <- read_tissue_expr(files_by_tissue[[t]], t)
aggregate_by_donor(M)
})
names(mats) <- names(files_by_tissue)
all_donors <- sort(unique(unlist(lapply(mats, rownames))))
all_genes  <- sort(unique(unlist(lapply(mats, colnames))))
Z <- matrix(NA_real_, nrow=length(all_donors), ncol=length(all_genes),
dimnames=list(all_donors, all_genes))
for (t in names(mats)) {
Z[rownames(mats[[t]]), colnames(mats[[t]])] <- mats[[t]]
}
Z
}
permuteVect <- function(v) sample(v, length(v), replace=FALSE)
lower_mean  <- function(M) { lt <- lower.tri(M); mean(abs(M[lt]), na.rm=TRUE) }
compute_MDC <- function(exprB, exprA, gene_idx, power=6) {
if (length(gene_idx) < 2) return(NA_real_)
XB <- exprB[, gene_idx, drop=FALSE]
XA <- exprA[, gene_idx, drop=FALSE]
corB <- abs(cor(XB, use="pairwise.complete.obs"))^power; diag(corB) <- 0
corA <- abs(cor(XA, use="pairwise.complete.obs"))^power; diag(corA) <- 0
lower_mean(corB) / lower_mean(corA)
}
empirical_p <- function(obs, null_vec) {
# one-sided: large MDC supports difference (≥)
(1 + sum(null_vec >= obs, na.rm=TRUE)) / (1 + sum(!is.na(null_vec)))
}
# ---------- IO setup ----------
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
dir.create(file.path(out_dir, "plots"), showWarnings = FALSE)
# ---------- 1) Build cohort matrices ----------
message("Assembling cohort matrices ...")
expr_old   <- assemble_cohort_matrix(files_old)
expr_young <- assemble_cohort_matrix(files_young)
message(sprintf("OLD: %d donors × %d genes | YOUNG: %d donors × %d genes | Common genes: %d",
nrow(expr_old), ncol(expr_old), nrow(expr_young), ncol(expr_young), length(common)))
clu <- read.delim(clusters_table_path, header=TRUE, check.names=FALSE)
required_cols <- c("Cluster ID", "Tissue", "Gene Symbol")
miss <- setdiff(required_cols, colnames(clu))
if (length(miss) > 0) stop("clusters table missing columns: ", paste(miss, collapse=", "))
clu$GeneID <- paste0(clu$Tissue, "_", clu$`Gene Symbol`)
gene2modID <- setNames(as.integer(clu$`Cluster ID`), clu$GeneID)
modulesID_young <- gene2modID[colnames(expr_young)]
modtb <- table(modulesID_young, useNA = "no")
mod_ids <- as.integer(names(modtb))
if (length(mod_ids) == 0) stop("No modules overlap the expression columns.")
# פונקציית עזר: אינדקסי הגנים של מודול ע"פ מזהה
genes_idx_of_module <- function(mid) which(modulesID_young == mid)
# רקמה של כל גן (ל־CT/TS; מפורק מהשם Tissue_Gene)
gene_tissue <- sub("_.*$", "", colnames(expr_young))
# ---------- 3) True MDC per module ----------
message("Computing true MDC per module ...")
yfold <- sapply(mod_ids, function(mid) {
idx <- genes_idx_of_module(mid)
compute_MDC(expr_young, expr_old, idx, power = corrlpower)
})
names(yfold) <- as.character(mod_ids)
# ---------- 4) Sample permutations ----------
message(sprintf("Sample permutations × %d ...", no.perms))
meanFoldChange <- replicate(no.perms, {
XBY <- apply(expr_young, 2, permuteVect)  # פרמוטציה לכל עמודה בנפרד
XAO <- apply(expr_old,   2, permuteVect)
sapply(mod_ids, function(mid) {
idx <- genes_idx_of_module(mid)
compute_MDC(XBY, XAO, idx, power = corrlpower)
})
})
rownames(meanFoldChange) <- as.character(mod_ids)
colnames(meanFoldChange) <- sprintf("MDC_random_samples_%02d", seq_len(no.perms))
# ---------- 5) Gene permutations ----------
message(sprintf("Gene permutations × %d ...", no.perms))
all_genes <- seq_len(ncol(expr_young))
GlobalyRandomMDC <- replicate(no.perms, {
sapply(mod_ids, function(mid) {
msize <- as.integer(modtb[as.character(mid)])
if (is.na(msize) || msize < 2) return(NA_real_)
idx <- sample(all_genes, msize, replace = FALSE)
compute_MDC(expr_young, expr_old, idx, power = corrlpower)
})
})
rownames(GlobalyRandomMDC) <- as.character(mod_ids)
colnames(GlobalyRandomMDC) <- sprintf("MDC_random_genes_%02d", seq_len(no.perms))
# ---------- 6) p-values & FDR ----------
# empirical p per module from each permutation family
p_samp <- vapply(seq_along(yfold), function(i) {
empirical_p(yfold[i], meanFoldChange[ names(yfold)[i], ])
}, numeric(1))
names(p_samp) <- names(yfold)
p_gene <- vapply(seq_along(yfold), function(i) {
empirical_p(yfold[i], GlobalyRandomMDC[ names(yfold)[i], ])
}, numeric(1))
names(p_gene) <- names(yfold)
q_samp <- p.adjust(p_samp, method = "BH")
q_gene <- p.adjust(p_gene, method = "BH")
q_max  <- pmax(q_samp, q_gene)
# ---------- 7) Save tables ----------
mod_ids_char <- names(yfold)
final <- data.frame(
module = as.integer(mod_ids_char),
size   = as.integer(modtb[mod_ids_char]),
MDC    = round(unname(yfold), 4),
p_random_samples = signif(unname(p_samp), 4),
q_random_samples = signif(unname(q_samp), 4),
p_random_genes   = signif(unname(p_gene), 4),
q_random_genes   = signif(unname(q_gene), 4),
q_combined_max   = signif(unname(q_max), 4),
check.names = FALSE
)
final <- final[order(-final$MDC), ]
stopifnot(all(rownames(meanFoldChange)   %in% mod_ids_char))
stopifnot(all(rownames(GlobalyRandomMDC) %in% mod_ids_char))
# Rebuild randoms properly (avoid transposition confusion):
randoms <- data.frame(
module = as.integer(mod_ids_char),
as.data.frame(meanFoldChange[mod_ids_char, , drop=FALSE], check.names = FALSE),
as.data.frame(GlobalyRandomMDC[mod_ids_char, , drop=FALSE], check.names = FALSE),
check.names = FALSE
)
colnames(randoms) <- c(
"module",
sprintf("MDC_random_samples_%02d", seq_len(ncol(meanFoldChange))),
sprintf("MDC_random_genes_%02d",  seq_len(ncol(GlobalyRandomMDC)))
)
write.table(final,
file = file.path(out_dir, paste0(run_name, "_MDC_wFDR.tsv")),
sep = "\t", quote = FALSE, row.names = FALSE)
write.table(randoms,
file = file.path(out_dir, paste0(run_name, "_MDC_randoms.tsv")),
sep = "\t", quote = FALSE, row.names = FALSE)
message("Saved: ", file.path(out_dir, paste0(run_name, "_MDC_wFDR.tsv")))
message("Saved: ", file.path(out_dir, paste0(run_name, "_MDC_randoms.tsv")))
# ---------- 8) Simple barplot ----------
png(file.path(out_dir, "plots", paste0(run_name, "_MDC_barplot.png")),
width = 2000, height = 900, res = 180)
op <- par(mar = c(9, 5, 3, 1))
lab <- final$module
cols <- rep_len(setdiff(colors(), c("white","grey","gray","lightgray")), length(lab))
stars <- ifelse(final$q_combined_max <= alpha, "*", "")
bp <- barplot(final$MDC, names.arg = lab, las = 2,
ylab = sprintf("MDC (k_%s / k_%s)", "young", "old"),
col = cols[seq_along(lab)], border = NA)
text(bp, final$MDC, labels = stars, pos = 3, cex = 1.1)
abline(h = 1, lty = 2)
par(op)
dev.off()
message("Saved: ", file.path(out_dir, "plots", paste0(run_name, "_MDC_barplot.png")))
# ---------- 9) Optional: per-module heatmaps (top K) ----------
topK <- min(12L, nrow(final))
dir.create(file.path(out_dir, "plots", "heatmaps"), showWarnings = FALSE)
# Order modules by MDC already in 'final'
for (z in seq_len(topK)) {
mid <- final$module[z]
idx <- genes_idx_of_module(mid)
if (length(idx) < 2) next
corB <- abs(cor(expr_young[, idx, drop=FALSE], use="pairwise.complete.obs"))^corrlpower
corA <- abs(cor(expr_old  [, idx, drop=FALSE], use="pairwise.complete.obs"))^corrlpower
diag(corB) <- 0; diag(corA) <- 0
ord <- order(rowSums(corB, na.rm=TRUE), decreasing = TRUE)
CB <- corB[ord, ord]; CA <- corA[ord, ord]
U  <- CB; L <- CA
U[lower.tri(U, diag=TRUE)] <- NA
L[upper.tri(L, diag=TRUE)] <- NA
M <- U; M[is.na(M)] <- L[is.na(M)]
png(file.path(out_dir, "plots", "heatmaps",
sprintf("%s_heatmap_module%d.png", run_name, mid)),
width = 800, height = 800, res = 140)
par(mar=c(2,2,2,2))
image(t(apply(M, 2, rev)), axes=FALSE, col = heat.colors(64),
main = sprintf("Module %d (top %d/%d genes)", mid, length(idx), as.integer(modtb[as.character(mid)])))
box()
dev.off()
}
message("Done numeric module MDC pipeline.")
# =====================================================================
source("~/CoExpression_ReProduction/old_scripts/CrossTissueClusteringMethods.R")
res <- XWGCNA_Clusters_autoBeta(
tissue_names = c("Adipose","Muscle","Brain"),
tissue_expr_file_names = c(
"/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Adipose - Subcutaneous/old_matrix.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Muscle - Skeletal/old_matrix.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_scripts/outputs/Brain - Cortex/old_matrix.csv"
),
sd_quantile = 0.0,
max_genes_per_tissue = 5000,     # if RAM is tight try 2000–3000
min_expr = 0,
min_prop = 0.10,
auto_beta = FALSE,
targetR2 = 0.80,
beta_grid = 1:20,
minClusterSize = 30,
cluster_type_thr = 0.95,
out_prefix = "xwgcna_old_oriiginal_run5",
save_intermediates = TRUE,
plot_heatmap = TRUE
)
source("~/CoExpression_ReProduction/old_scripts/CrossTissueClusteringMethods.R")
res <- XWGCNA_Clusters_autoBeta(
tissue_names = c("Adipose","Muscle","Brain"),
tissue_expr_file_names = c(
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Adipose - Subcutaneous_old.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Muscle - Skeletal_old.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Brain - Cortex_old.csv"
),
sd_quantile = 0.0,
max_genes_per_tissue = 5000,     # if RAM is tight try 2000–3000
min_expr = 0,
min_prop = 0.10,
auto_beta = FALSE,
targetR2 = 0.80,
beta_grid = 1:20,
minClusterSize = 30,
cluster_type_thr = 0.95,
out_prefix = "xwgcna_old_oriiginal_run6",
save_intermediates = TRUE,
plot_heatmap = TRUE
)
source("~/CoExpression_ReProduction/old_scripts/CrossTissueClusteringMethods.R")
res <- XWGCNA_Clusters_autoBeta(
tissue_names = c("Adipose","Muscle","Brain"),
tissue_expr_file_names = c(
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Adipose - Subcutaneous_young.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Muscle - Skeletal_young.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Brain - Cortex_young.csv"
),
sd_quantile = 0.0,
max_genes_per_tissue = 5000,     # if RAM is tight try 2000–3000
min_expr = 0,
min_prop = 0.10,
auto_beta = FALSE,
targetR2 = 0.80,
beta_grid = 1:20,
minClusterSize = 30,
cluster_type_thr = 0.95,
out_prefix = "xwgcna_young_oriiginal_run6",
save_intermediates = TRUE,
plot_heatmap = TRUE
)
source("~/CoExpression_ReProduction/old_scripts/CrossTissueClusteringMethods.R")
res <- XWGCNA_Clusters_autoBeta(
tissue_names = c("Adipose","Muscle","Brain"),
tissue_expr_file_names = c(
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Adipose - Subcutaneous_old.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Muscle - Skeletal_old.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Brain - Cortex_old.csv"
),
sd_quantile = 0.0,
max_genes_per_tissue = 5000,     # if RAM is tight try 2000–3000
min_expr = 0,
min_prop = 0.00,
auto_beta = FALSE,
targetR2 = 0.80,
beta_grid = 1:20,
minClusterSize = 30,
cluster_type_thr = 0.95,
out_prefix = "xwgcna_old_oriiginal_run7",
save_intermediates = TRUE,
plot_heatmap = TRUE
)
source("~/CoExpression_ReProduction/old_scripts/CrossTissueClusteringMethods.R")
res <- XWGCNA_Clusters_autoBeta(
tissue_names = c("Adipose","Muscle","Brain"),
tissue_expr_file_names = c(
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Adipose - Subcutaneous_old.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Muscle - Skeletal_old.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Brain - Cortex_old.csv"
),
sd_quantile = 0.0,
max_genes_per_tissue = 5000,     # if RAM is tight try 2000–3000
min_expr = 0,
min_prop = 1.00,
auto_beta = FALSE,
targetR2 = 0.80,
beta_grid = 1:20,
minClusterSize = 30,
cluster_type_thr = 0.95,
out_prefix = "xwgcna_old_oriiginal_run7",
save_intermediates = TRUE,
plot_heatmap = TRUE
)
source("~/CoExpression_ReProduction/old_scripts/CrossTissueClusteringMethods.R")
res <- XWGCNA_Clusters_autoBeta(
tissue_names = c("Adipose","Muscle","Brain"),
tissue_expr_file_names = c(
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Adipose - Subcutaneous_old.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Muscle - Skeletal_old.csv",
"/Users/edeneldar/CoExpression_ReProduction/old_outputs/Brain - Cortex_old.csv"
),
sd_quantile = 0.0,
max_genes_per_tissue = 5000,     # if RAM is tight try 2000–3000
min_expr = 0,
min_prop = 0.01,
auto_beta = FALSE,
targetR2 = 0.80,
beta_grid = 1:20,
minClusterSize = 30,
cluster_type_thr = 0.95,
out_prefix = "xwgcna_old_oriiginal_run7",
save_intermediates = TRUE,
plot_heatmap = TRUE
)
